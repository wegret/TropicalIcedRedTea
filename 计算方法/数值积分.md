[TOC]



# 数值积分

## 引入：什么是数值积分？

给定一个函数$f(x)$，要计算积分$\int_a^b f(x)dx$时，往往有一些困难。朴素的方法是求出原函数$F(x)$，然后利用牛顿-莱布尼茨公式$F(b)-F(a)$计算，但是很多函数是没有原函数或者原函数计算困难的，所以这种方法并不通用，需要寻找更加通用的方法。

由积分中值定理，可以知道$$\int _a^b f(x)dx=(b-a)f(\xi)$$

这里的$f(\xi)$，我们可以把它视为平均高度。可以考虑用这个公式来计算积分值，不过因为平均高度是比较难求的，所以会有一些近似的方式。

**梯形公式**：$\int_a^b f(x)dx\approx (b-a) \frac{f(a)+f(b)}{2}$（取两个端点高度的均值作为平均高度）

**矩形公式**：$\int_a^b f(x)dx\approx (b-a) f(\frac{a+b}{2})$（取两个端点中值的高度作为平均高度）

进一步，我们可以归纳出求积公式的一般形式：在区间$[a,b]$上选取一些节点$x_k$，然后用$f(x_k)$的加权平均值近似出平均高度$f(\xi)$：
$$
\int_a^b f(x)dx\approx \sum_{k=0}^n A_k f(x_k)
$$

### 误差分析

称$R(f)=\int_a^bf(x)dx-\sum_{k=0}^n A_k f(x_k)$为求积公式的截断误差或余项。

**代数精度**  如果一个数值积分公式对于所有次数不超过 $m$ 的代数多项式 $f(x)$ 的积分能够精确计算（即，该积分公式的误差 $R(f)=0$），那么我们说这个积分公式至少具有 $m$ 次的代数精度。

例如，梯形公式的代数精度就是1，它对于所有直线（一次函数）都能很好地算出积分。而后面的辛普森公式，代数精度是2，至少具有2次代数精度。

------

**例题**：判定下列积分公式的代数精度
$$
\int_0^1f(x)dx\approx \frac{1}4\left[f(0)+2f(\frac12)+f(1)\right]
$$
$n=0$时，$f(x)=1$，$\int_0^1f(x)dx=1$，计算求积公式结果为$1$。

$n=1$时，$f(x)=x$，$\int_0^1f(x)dx=\frac12$，计算求积公式结果为$\frac12$。

$n=2$时，$f(x)=x^2$，$\int_0^1f(x)dx=\frac13$，计算求积公式结果为$\frac38$，不符合。

故具有$1$次代数精度。

**例题**：给定如$\int_0^1 f(x)dx=\approx A_0f(0)+A_1f(1)+B_0 f'(0)$的求积公式，确定$A_0$，$B_0$以尽可能高地提升代数精确度。

直接把$1$，$x$，$x^2$...往里面带入即可。三个参数，估计代数精度大约为2，解答时对这些x的幂逐个验证直到不满足即可。

------

### 插值型求积公式

由插值法中的拉格朗日插值法，可以得到一个计算积分的思路。

首先选定一组点（通常是积分区间内的若干点），这些点称为插值点。使用拉格朗日插值法根据这些插值点上的函数值构造一个插值多项式。然后将函数$f(x)$在积分区间$[a,b]$上的积分$\int_a^bf(x)dx$近似为插值多项式的积分。
$$
\int_a^bf(x)dx\approx \int_a^b L(x)dx=\int_a^b \sum_{k=0}^n y_kl_k(x)dx
$$
也就是说，通过用拉格朗日插值拆解成多个基函数，然后对每个基函数在区间上积分，最后累加。

误差上，用这个来积分，误差其实就相当于拉格朗日拟合的误差
$$
\begin{aligned}
R(f)&=\int_a^b f(x)dx-\sum_{i=0}^n A_if(x_i)\\
&=\int_a^b \frac{f^{(n+1)}(\xi)}{(n+1)!}w_{n+1}(x)dx
\end{aligned}
$$
在数值积分中，如果一个插值型求积公式具有$n+1$个求积节点，那么它能够精确地积分所有多达 $n$ 次的多项式。这被称为求积公式的**代数精度**。这个是很显然，在插值法中我们就已经知道，$n$次的多项式能通过$n+1$个求积节点来完全精确地插值拟合，因此$n+1$个节点的插值型求积公式能精确积分$n$次多项式也不奇怪。

### 收敛性

在求积公式中，若
$$
\lim_{n\rightarrow \infty,h\rightarrow 0}\sum_{k=0}^n A_k f(x_k)=\int_a^bf(x)dx
$$
也就是说，在分块越多，就能越提升精度，到最后完全逼近$f(x)$，这种求积公式就是收敛的。

## 一. 牛顿-柯特斯求积公式

如果在插值型求积公式中，在$[a,b]$上选取等距的$n$个点，求积公式就变成了
$$
\int_a^b f(x)dx\approx \sum_{i=0}^n A_i f(x_i)\\
这里的A_i=\int_a^b l_i(x)dx
$$
这就是牛顿-柯特斯求积公式。按照《数值分析》这本书的写法，也可以写成这样
$$
I_n=(b-a)\sum_{k=0}^n C_k^{(n)}f(x_k)\\
x_k=a+kh，这里的h是步长，h=\frac{b-a}{h}
$$
这里的$C_k^{(n)}$需要一点时间推导，先略了。总之很显然，这是一个只与$n$和$k$有关的常数。

$n=1$的时候，$C_0^{(1)}=C_1^{(2)}=\frac{1}{2}$，是梯形公式。

$n=2$的时候，是**辛普森公式**，或者说是抛物线公式：
$$
S=\frac{b-a}{6}\left[f(a)+4f(\frac{a+b}{2})+f(b)\right]
$$
$n=4$的时候，特别称为柯特斯公式，这个公式的形式没什么美感
$$
C=\frac{b-a}{90}\left[ 7f(x_0)+32f(x_1)+12f(x_2)+32f(x_3)+7f(x_4)\right]
$$
看不出有任何值得记忆的必要。

理论上可以通过打表法，把牛顿-柯特斯公式的所有系数都算出来。

### 辛普森公式

在前面我们已经知道，辛普森公式是
$$
S=\frac{b-a}{6}\left[f(a)+4f(\frac{a+b}{2})+f(b)\right]
$$
这个公式作为二阶的插值公式，天然具有二次代数精度。但是它只有二次的代数精度吗？实际上我们很容易把$f(x)=x^3$带进去检验一下，可以发现辛普森公式实际上是具有三次代数精度的。

由此，我们可以证明一个更加泛用的定理：

**定理**    阶数$n$是偶数的时候，牛顿柯特斯公式能具有$n+1$的代数精度。

（因此，我们可以发现，在使用时我们完全用不上$n=3$的柯特斯公式，因为完全可以由更低阶的辛普森公式代替。）

经过计算可以得到一些公式的余项：

|          |阶数| 余项                           |
| -------- |--| ------------------------------ |
| 梯形公式 |$n=1$| $R[f]=-\frac{(b-a)}{12}(b-a)^2f''(\eta )\\R[f]=-\frac{(b-a)}{12}h^2f''(\eta )$ |
| 辛普森公式 | $n=2$ | $R[f]=-\frac{(b-a)}{180}(\frac{b-a}{2})^4 f^{(4)}(\eta)\\R[f]=-\frac{(b-a)}{180}h^4 f^{(4)}(\eta)$ |
| 柯特斯公式 | $n=4$ | $R[f]=-\frac{2(b-a)}{945}(\frac{b-a}{4})^6 f^{(6)}(\eta)$ |

------

**例题**：用辛普森公式求积分$\int_0^1 e^{-x}dx$并估计误差。

由辛普森公式，计算积分
$$
\begin{aligned}
S&=\frac{1-0}{6}[f(0)+4\times f(\frac 1 2)+f(1)]\\
&=\frac{1}{6}[1+4\times \frac{1}{\sqrt{e}}+\frac{1}{e}]\\
&=0.63233
\end{aligned}
$$
误差估计直接套公式了
$$
\begin{aligned}
|R(f)|&=-\frac{(b-a)}{180}h^4f^{(4)}(\eta)\\
&=\left|-\frac{1}{180}\times (\frac 1 2)^4 f^{(4)}(\eta) \right|
\end{aligned}
$$

由$f^{(4)}(\eta)=e^{-\eta}\leq 1$
$$
|R(f)|\leq 0.00034722
$$


------



### 复化求积公式

从前面我们可以看出来，我们希望求积精度尽可能地搞，但是次数越高的函数，需要的求积公式阶数越高。为了用低阶的公式来实现高精度求积，我们可以复化一下。

将区间$I$划分为$n$等分，先用低阶的牛顿-柯特斯公式求得每个子区间上的积分值，然后把它们的和作为整个区间$I$上积分的近似值。

#### 复化梯形公式

$$
S=\frac{h}{2}[f(a)+2*\sum f(x_k)+f(b)]
$$

朴素形式下的梯形公式是$S=\frac{h}{2}[f(a)+f(b)]$，其中$h=(b-a)$。但是推广到复合梯形公式中，因为多了许多插值点，因此因子一个由两端点函数值之和，变成了所有插值点的函数值之和的2倍（如果把两个端点视为一个点），同时的，$h=\frac{b-a}{n}$，这里的$n$是步长，是取点数-1，也就是区间个数。

按区间就很好理解，$$S=\frac{f(a)+2*\sum f(x_k)+f(b)}{2}*h$$，这里左部分$\frac{f(a)+2*\sum f(x_k)+f(b)}{2}$，相当于$h$个区间高度的均值，右边是区间步长。

#### 复化辛普森公式

$$
S=\frac{f(a)+4\sum f(x_k+\frac{1}{2})+2\sum f(x_k)+f(b)}{6}*h
$$

复合辛普森公式，和复合梯形公式有些类似。

### 龙贝格求积法

#### 梯形递推法

龙贝格求积法，实际上就是通过前面复化的思路得到的。在大多数问题中，我们很难预判需要达到这个精度，需要把区间划分多少份。因此，我们可以先计算，然后在精度不够时，继续将每个区间二分。
$$
T_{2n}=\frac12T_n+\frac h2\sum_{k=0}^{n-1}f(x_{k+\frac12})\\
注意，这里h=\frac{b-a}{n}是二分前的步长
$$
这样的确可以，但是我们实际上来计算一下，会发现这个精度提升的速度还不够快。能不能提升速度？

#### 误差估计与加速

我们实际上可以来估计一下误差。
$$
I-T_n=-\frac{(b-a)}{12}h^2 f''(\eta)\\
I-T_{2n}=-\frac{(b-a)}{12}(\frac{h}{2})^2 f''(\overline{\eta})\\
$$
假定$f''(\eta)\approx f''(\overline{\eta})$，我们就可以上下除一下，得到
$$
\frac{I-T_{2n}}{I-T_n}\approx \frac 1 4（每二分一次，精度提升4倍）
$$
进行一番整理，得到
$$
I-T_{2n}\approx \frac{1}{3}(T_{2n}-T_n)
$$
既然估计出了误差，我们实际上可以把这个估计出的误差加上去
$$
I=\frac 4 3 T_{2n}-\frac 1 3 T_n
$$
同理，如果用精度更高的复合辛普森公式
$$
\frac{I-S_{2n}}{I-S_n}\approx \frac{1}{16}
$$
预估出的值
$$
C_n=\frac{16}{15}S_{2n}-\frac{1}{15}S_n
$$

#### 理查德外推加速法

从梯形到辛普森公式（其实还可以进一步算柯特斯），可以看出来这个预估值是有点规律的，直接开始猜测，
$$
T_m^{(k)}(h)=\frac{4^m}{4^m-1}T_{m-1}^{(k+1)}-\frac{1}{4^m-1}T_{m-1}^{(k)}\\
k表示二分了几次，m表示加速了几次
$$

#### 龙贝格算法

令$h=b-a$，先初始化出$T_{0}^{(0)}=\frac{h}{2}[f(a)+f(b)]$

$k=1$，开始第一层二分，先算出不带加速的$T_0^{(k)}$：
$$
T_0^{(k)}=\frac{1}{2}\left[T^{(k-1)}_0+h\sum_{i=1}^{n-1}f(x_{k+\frac{1}{2}})\right]
$$
然后开始外推，根据上述的加速公式，$m=1,2,...,k$，算$T^{(k-m)}_m$

如果$|T_k^{(0)}-T_{k-1}^{(0)}|<\epsilon $，就终止计算。



## 二. 高斯型求积公式

前面的牛顿柯特斯求积公式，节点等距分布，通过调整权重，来提升精度。

而高斯型求积公式不是，它连着节点的分布也纳入精度的考虑。它是根据正交多项式的根来选择的，例如勒德让多项式、切比雪夫多项式等，而权重也是根据对应的正交多项式确定的，确保公式对于给定的多项式基，能达到最高的精度。

在数值积分中，当一个具有$n+1$个节点的求积公式的代数精度达到 $2n+1$ 次时，这种类型的求积公式被称为**高斯型求积公式**，它是利用了特别选取的求积节点（称为高斯型节点）来达到这种高度的精度。

一般来说，可以表示为
$$
\int_a^b f(x)dx\approx \sum_{i=1}^n w_i f(x_i)
$$

------

**例题**：试着构造高斯型求积公式
$$
\int_0^1 \frac{1}{\sqrt{x}}f(x)dx\approx A_0f(x_0)+A_1f(x_1)
$$
这种题一般就是确保它能具有$3$次精度即可，$f(x)$代入$1,x,x^2,x^3$然后硬解就行。

------

**例题**：设$\{\varphi_n(x)\}$是$[a,b]$上带权$\rho(x)$的正交多项式序列，$x_i(i=0,1,2,...,n)$是$\varphi_{n+1}(x)$的零点，$l_i(x)(i=0,1,2,...,n)$是以$\{x_i\}$为节点的拉格朗日插值基函数，高斯型求积公式为
$$
\int_a^b \rho(x)f(x)dx\approx \sum_{k=0}^n A_k f(x_k)
$$
证明：（1）当$0\leq k,l \leq n,k\neq l$时，$\sum_{i=0}^n A_i\varphi_k(x_i)\varphi_l(x_i)=0$

（2）$\sum_{k=0}^n \int_a^b \rho(x)l_k^2(x)dx=\int_a^b \rho(x)dx$

证明：（1）由于$\{\varphi_n(x)\}$是$[a,b]$上带权$\rho(x)$的正交多项式序列，因此
$$
\forall k,l\in [0,n],k\neq l,\\
\int_a^b \rho(x)\varphi_k(x)\varphi_l(x)dx=0
$$
由高斯求积公式，若$f(x)=\varphi_k(x)\varphi_l(x)$，则可以得到
$$
\sum_{i=0}^n A_i \varphi_k(x_i)\varphi_l(x_i)=0
$$
得证。

（2）设$f(x)=l_k^2(x)$，因此
$$
\begin{aligned}
\sum_{k=0}^n \int_a^b\rho(x)l_k^2(x)dx=\sum_{k=0}^n\sum_{j=0}^n A_jl_k^2(x_j)
\end{aligned}
$$
根据基函数的性质
$$
l_k^2(x_j)=\begin{cases}
1 & k=j\\
0 & k\neq j
\end{cases}
$$
因此进一步推导
$$
\begin{aligned}
\sum_{k=0}^n \int_a^b\rho(x)l_k^2(x)dx&=\sum_{k=0}^n\sum_{j=0}^n A_jl_k^2(x_j)\\
&=\sum_{k=0}^n A_k\\
&=\sum_{k=0}^n A_k\cdot 1\\
&=\int_a^b \rho(x)dx
\end{aligned}
$$
得证。



