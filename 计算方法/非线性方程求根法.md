[TOC]



# 非线性方程（组）求根

## 引入

若给了一个函数方程
$$
f(x)=0
$$
它的解$x=x^*$，被称为这个方程的根或者说零点。

如果$f(x)$可以分解为
$$
f(x)=(x-x^*)^mg(x)
$$
且这里的$g(x^*)\neq 0$，那么，就说$x^*$是$f(x)$的**$m$重零点**或者说$f(x)=0$的**$m$重根**。如果$m=1$时，称$x^*$是$f(x)$的单根，或者说单零点。

### 有解的条件

很显然不是所有方程都有零点，一个简单的根的存在定理如下：

**定理**    假设函数$y=f(x)\in C[a,b]$，且$f(a)\cdot f(b)<0$，则至少存在一点$x^*\in(a,b)$使得$f(x^*)=0$

**定理**    假设函数$y=f(x)\in C[a,b]$，且$f(a)\cdot f(b)<0$，若$f(x)$在$[a,b]$上单调连续，则恰存在一点$x^*\in(a,b)$使得$f(x^*)=0$

**定理**    假设函数$y=f(x)$在$x=x^*$的某一邻域内充分可微，则$x^*$是方程$f(x)=0$的$m$重根的充要条件是
$$
f(x^*)=f'(x^*)=...=f^{(m-1)}(x^*)=0\\
f^{(m)}(x^*)=0
$$

## 一.  二分法

```python
def f(x):  # 函数f(x)
    return x**2 - 4  # 举例：寻找方程x^2 - 4 = 0的根

def bisection_method(l, r, eps=1e-5):
    if f(l) * f(r) > 0:
        print("f(l) and f(r) should have opposite signs")
        return None
    
    while (r - l) / 2 > eps:
        mid = (l + r) / 2 
        if f(mid) == 0: 
            return mid
        elif f(l) * f(mid) < 0: 
            r = mid
        else:
            l = mid
    return (l + r) / 2  
```

二分法的优点很明显，它非常简单，而且含义很直观，在确定了端点异号区间的情况下，最终一定能取得一个答案。

它的不足也很明显。它在面对类似下图的两种函数时，都不适用：

<iframe src="https://www.desmos.com/calculator/yc7kwdlguj?embed" width="250" height="250" style="border: 1px solid #ccc" frameborder=0></iframe>

## 二.  迭代法

### 不动点迭代法

#### 思路

和其他迭代法一样，对于一个方程$f(x)$，考虑构造迭代方程
$$
x=\varphi (x)
$$
来利用多次迭代$x^{(k+1)}=\varphi (x^{(k)})$求解近似根。

这个思路也很显然，对于方程$f(x)=0$，通过代数变形，得到迭代方程$x=\varphi (x)$。例如$f(x)=x^2-x=0$，可以变形得到$x=x^2$，右侧的$x^2$即是$\varphi(x)$。和其他迭代法一样，任意选取一个初始的猜测值，然后不断代入，如果最终能收敛到一个点上$x^*$，那这个就是解（或者按照高中数学的说法，叫不动点）

#### 几何意义

对于$f(x)=0$，在变形成$x=\varphi (x)$后，在几何意义上，实际上就是在找$y=x$和$y=\varphi(x)$的交点。例如前面写的$f(x)=x^2-x$，转换成迭代方程$x=\varphi(x)=x^2$，实际上就是找下面的交点：

<iframe src="https://www.desmos.com/calculator/hhsroyvk3w?embed" width="300" height="300" style="border: 1px solid #ccc" frameborder=0></iframe>



换个更复杂的例子，$f(x)=x^3-x-1=0$，如果要求在$x_0=1.5$附近的根。

设计的迭代方程很明显有多种：

$\varphi_1 (x)=x^3-1$

$\varphi_2(x)=\frac{x+1}{x^2}$

$\varphi_3 (x)=(x+1)^{\frac{1}{3}}$

但是都能收敛吗？

#### 收敛条件

假设函数$\varphi(x)$满足：

① 对于任意的$x\in[a,b]$有$a\leq \varphi(x)\leq b$

（实际上就是在$[a,b]$内函数与$y=x$有交点）

② 存在正数$L<1$，使得区间$[a,b]$内的任意$x_1,x_2$，都有$|\varphi(x_1)-\varphi(x_2)|\leq L |x_1-x_2|$,$0\leq L<1$。

（实际上就是在$x_1\neq x_2$的情况下，有$\frac{|\varphi(x_1)-\varphi(x_2)|}{|x_1-x_2|}\leq L<1$，或者说，在这段区间内，函数的梯度的绝对值，具有一个小于1的上界）

（或者还可以直接写成等价的条件：
$$
|\varphi'(x)|\leq L<1, \space x\in(a,b)
$$
满足上述两个条件，则迭代过程中对于任意的初始值$x_0\in[a,b]$，都会收敛到根$x^*$。

如何理解？我认为是条件①保证了有至少一个解，条件②保证了整个区间内导数的绝对值都小于1，确保了迭代过程中是“温和”的。

为什么需要条件②？假设不考虑这个条件，以迭代方程$\varphi_2(x)=\frac{x+1}{x^2}$为例，它的迭代过程如下图：

<iframe src="https://www.desmos.com/calculator/juqbuohmv3?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

这个迭代过程可以如图这样理解，假设初始随机取了点`(1)`，然后经过一次迭代，到达点`(2)`，然后继续迭代，到达点`(3)`……不难看出趋势，这是不收敛的。每次从$x^{(k)}$跳到$x^{(k+1)}$，因为$\varphi(x^{(k)})$和$\varphi(x^{(k+1)})$的距离大于$x^{(k)}$和$x^{(k+1)}$的距离，必然导致因此它跳跃距离必然是越来越大的。从上述迭代过程可以理解为什么需要约束导数上界小等于1。

#### 误差估计

在满足上述两个条件后，可以估计误差
$$
\frac{|x^{(k)}-x^*|}{|x_1-x_0|}\leq \frac{L^k}{1-L}
$$
可以用这个公式估计误差上界。

#### 局部收敛性

设$\varphi(x)$有不动点$x*$, 如果存在$x^*$的某个邻域$R:|x-x^*|\leq \delta $ ，使迭代过程$x^{(k+1)}=\varphi (x^{(k)})$对于任意初值$x_0\in R$均收敛，则称迭代过程$x^{(k+1)}=\varphi(x^{(k)})$在根$x^*$邻近具有局部收敛性。

很显然可以推导出下面的定理

**定理**   设$x^*$为方程$x=\varphi(x)$的根，$\varphi'(x)$在$x^*$附近连续，且$|\varphi'(x)|<1$，则迭代过程$x^{(k+1)}=\varphi (x^{(k)})$在$x^*$附近有局部收敛性。

#### 收敛速度

**定义**    设迭代过程 $x_{k+1} = \varphi(x_k)$ 收敛于方程 $x = \varphi(x)$ 的根 $x^*$。如果迭代误差 $e_k = x_k - x^*$ 当 $k \rightarrow \infty$ 时满足下列渐进关系式：
$$
e_{k+1} \approx C |e_k|^p \quad (C \neq 0, p > 0)
$$
则称该迭代过程是 **p阶收敛** 的。特别地，当 $p = 1$ 时为**线性收敛**，$p > 1$ 时为**超线性收敛**，$p = 2$ 时为**平方收敛**。

**定理**    对于迭代过程，如果 $$\varphi$$ 在所求根的邻近连续，并且
$$
\varphi'(x^*) = \varphi''(x^*) = \ldots = \varphi^{(p-1)}(x^*) = 0; \quad \varphi^{(p)}(x^*) \neq 0
$$
则该迭代过程在点 $$x^*$$ 邻近是$p$阶收敛的。

因此，迭代过程的收敛速度依赖于迭代函数。如果选取当$\varphi '(x)\neq 0$，则该迭代过程是线性收敛。

### 迭代法的加速：埃特金法

在龙贝格积分中，用理查德外推，能加速数值积分的速度。迭代法中有没有类似的加速算法？

加速过程中，思路是假设误差以一种线性的方式发生，也就是说每次迭代后误差都大致减少一个大致的比例$L$。因此，设$x^*$的第$k$步近似值是$x_k$，再用一次迭代公式
$$
x_{k+1}=\varphi (x_k)
$$
假设$\varphi '(x)$在这个范围中变化不大，因为有上限$L$，直接估计成$L$
$$
x^*-x_{k+1}=\varphi(x^*)-\varphi(x_k)\approx L(x^*-x_k)
$$
现在我们把这个误差的递减，估计成了上述的式子。能不能通过这个已知的估计，外推出下一次的迭代的改进估计？对上式进行整理，可以得到
$$
x^*\approx \frac{x_{k+1}-Lx_k}{(1-L)}
$$
也可以理解成$x_{k}$和$x_{k+1}$进行加权累加后得到预估的$x^*$。

但是这里往往涉及到一个对$L$的估计，这个就不太方便实际应用，因为不同的估计影响会很大。能不能把$L$消掉？再做一次迭代
$$
x_{k+2}=\varphi(x_{k+1})
$$
也就是
$$
x^*-x_{k+2}\approx L(x^*-x_{k+1})\\
x^*-x_{k+1}\approx L(x^*-x_k)
$$
上下除一下，消掉$L$，然后进一步整理得到公式
$$
x^*=\frac{x_{k+1}^2-x_kx_{k+2}}{2x_{k+1}-x_k-x_{k+2}}
$$
根据上面的推导，可以得到埃特金加速算法，也就是根据前面两步，外推得到一个估计的$\overline{x}_{k}$。

### 迭代法的加速：斯特芬迭代

把埃特金加速法和不动点迭代结合，可以得到一种迭代法。在埃特金迭代中，假设我们把这个估计函数记录成
$$
x^*=\text{Aitken}(x_{k},x_{k+1},x_{k+2})
$$
斯特芬迭代中，直接再构造两个序列$y$和$z$，其中
$$
y_k=\varphi(x_k)\\
z_k=\varphi(y_k)\\
$$
相当于接替了埃特金中的$x_{k+1}$和$x_{k+2}$。

因此，斯特芬迭代的算法是这样的：
$$
x_{k+1}=\text{Aitken}(x_k,y_k,z_k)
$$
相当于，这个迭代序列，在算出每个$x_k$后，我们要用迭代方程再外推两次，用这个外推出的值，去预估算下一个序列$x_{k+1}$。



## 三.  牛顿迭代法（切线法）

牛顿法是思路是通过线性化来逼近零点。

<a href="https://imgse.com/i/pkt09VH"><img style="height: 300px; width: auto" src="https://s21.ax1x.com/2024/06/08/pkt09VH.png" alt="pkt09VH.png" border="0" /></a>

线性化，很明显直接考虑到泰勒展开。取$x^*$附近的解，将$f(x)$在$x_0$做一阶的泰勒展开
$$
f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(\xi )}{2!}(x-x_0)^2
$$
在牛顿法中，我们先忽略二阶以上的小量
$$
f(x^*)\approx f(x_0)+f'(x_0)(x^*-x_0)\\
$$

$$
\begin{aligned}
x^*&=x_0+\frac{f(x^*)-f(x_0)}{f'(x_0)}\\
&=x_0-\frac{f(x_0)}{f'(x_0)}
\end{aligned}
$$

因此用这个迭代公式迭代：
$$
x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)}
$$
很显然，只要每一步有$f'(x_k)\neq 0$并且$\lim_{k\rightarrow\infty}x_k=x^*$，那么$x^*$就是$f(x)$的根。

### 收敛性

**定理**    设$f(x)$在$[a,b]$上满足下列条件：

​	① $f(a)\cdot f(b)<0$（端点异号，至少有一个零点）

​	② $f'(x)\neq 0$（不存在零导数点，零导数点会使得迭代无法进行，这里也隐含了要求$f(x)$单调，也就是说根是唯一的）

​	③ $f''(x)$存在且不变号（保证凹凸性不变，避免迭代路径出现非预期的行为，比如在接近根时突然偏离）

​	④ 取$x_0\in[a,b]$，使得$f''(x)\cdot f(x_0)>0$

​	则牛顿迭代序列会收敛于$f(x)$在$[a,b]$上的唯一根$x^*$。

（尽管如此，牛顿法的收敛性仍然依赖于$x_0$的选择，有可能算出来的$x_{k+1}$会超出$[a,b]$范围。）

### 简化牛顿法（平行弦法）

牛顿法显然是很快的。但是它有缺点，是每一步都需要算$f(x_k)$和$f'(x_k)$，这比较麻烦了。如何改进？

一种简单思路，是既然每次都要算$f'(x_k)$，而我们此前保证了$f''(x)$是不变号的，并且$f''(x)\cdot f(x_0)>0$，也就是说，我们其实完全可以用第一次的斜率代替后面所有的导数，也可以收敛到解。

不过问题就在于可能会变慢。

### 牛顿下山法

牛顿法的还有一个问题，就是过于依赖$x_0$的选择。因此可以引入牛顿下山法。

牛顿下山法为了防止发散，要确保每次迭代不仅向根的方向前进，而且还确保函数值的绝对值在每次迭代后都有所减少，也就是满足
$$
|f(x_k)|>|f(x_{k+1})|
$$
如何才能满足确定递减？牛顿下山法在朴素的牛顿法中，引入了步长，或者说下山因子$\lambda$。迭代公式
$$
x_{k+1}=x_k-\lambda \frac{f(x_k)}{f'(x_k)} &,& 0<\lambda \leq 1\\
$$
牛顿下山法和朴素的牛顿法一样，先选取初始近似值$x_0$，然后先取$\lambda=1$，计算第一步的迭代
$$
x_{k+1}=x_k-\lambda \frac{f(x_k)}{f'(x_k)}
$$
 计算$f(x_{k+1})$，比较一下$|f(x_{k+1})|$和$|f(x_{k})|$。

① 如果$|f(x_{k+1})|<|f(x_{k})|$，说服符合递减的要求，直接确定了$x_{k+1}$，继续循环操作，直到如果$|x_{k+1}-x_k|$已经足够小，结束循环。

② 如果$|f(x_{k+1})|\geq|f(x_{k})|$，说明不符合递减！那就减少步长$\lambda$，这里的减少，可以是$\lambda=\lambda/2$，重复计算$x_{k+1}=x_k-\lambda \frac{f(x_k)}{f'(x_k)}$，直到找到的$x_{k+1}$满足条件。

如果下山因子$\lambda$已经足够小（继续降低已经意义不大），但是$|f(x_k)|$还不够小，这时候选择对$x_{k+1}$做小的调整，$x_{k+1}=x_{k+1}+\delta$，调整。直到下山因子和$|f(x_k)|$都足够小，结束循环。

### 收敛速度

牛顿迭代法，对于单根方程是平方收敛的。推导也很好推导
$$
x=\varphi(x)=x-\frac{f(x)}{f'(x)}
$$
对迭代方程求导
$$
\begin{aligned}
\varphi'(x)&=1-\frac{[f'(x)]^2-f(x)f''(x)}{[f'(x)]^2}\\
&=\frac{f(x)f''(x)}{[f'(x)]^2}
\end{aligned}
$$
因为单根方程，$f'(x)>0$，$f(x^*)=0$，因此直接给出是平方收敛的。

------

**例题：**利用牛顿迭代法计算$x^2-7=0$的正根，若$x_k$是$\sqrt{7}$的具有$n$位有效数字的近似值， 求证$x_{k+1}$是$\sqrt{7}$的具有$2n$位有效数字的近似值。 

由$f(x)=x^2-7$
$$
\begin{aligned}
\varphi(x)&=x-\frac{f(x)}{f'(x)}\\
&=x-\frac{x^2-7}{2x}\\
&=x-\frac{1}{2}x+\frac{7}{2x}\\
&=\frac{1}{2}x+\frac{7}{2x}
\end{aligned}
$$
对$\varphi(x)$求导
$$
\varphi'(x)=\frac{1}{2}-\frac{7}{2x^2}
$$
由$\varphi'(\sqrt7)=0$，知道在根的附近牛顿法至少是平方收敛的，因此
$$
k\rightarrow \infty, e_{k+1}=Ce^{2}_k
$$
因此当$x_k$具有$n$位有效数字时，$x_{k+1}$应具有$2n$位有效数字。

------

## 三. 弦截法

牛顿法中，不可避免用了$f'(x_k)$，对于很多函数，要求求导是比较复杂的。为了改进这一点，引入了弦截法。

牛顿法依赖于函数在当前估计点的切线来找到下一个估计点。与之相比，弦截法使用的是两个最近估计点上的函数值来估计这个“切线”。这条通过两点的直线（弦）近似代替了切线。

具体地说，假设目前有了两个近似根$x_{k-1}$和$x_{k+1}$，可以像下图这样迭代：

<iframe src="https://www.desmos.com/calculator/s9ug2yi7vs?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

从上图随意选的$k-1$、$k$点，迭代出$k+1$、$k+2$，可以看出这个是逐渐向着零点迭代的。

牛顿法是一步迭代，而弦截法是两步迭代，在计算$x_{k+1}$时要用到前两步的结果，因此初始必须预估两个点$x_0$和$x_1$。

迭代方程
$$
x_{k}=x_{k-1}-\frac{f(x_{k-1})}{f(x_{k-1})-f(x_{k-2})}(x_{k-1}-x_{k-2})
$$

## 四. 抛物线法（Muller法）

弦截法，取了两个近似根来迭代，而抛物线法则取了三个近似根$x_k,x_{k-1},x_{k-2}$来构造二次插值多项式$p_2(x)$，然后选$p_2(x)$的一个零点作为$x_{k+1}$。

